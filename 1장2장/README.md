# 1장 계층형 아키텍처의 문제

- 1장
  - 계층형 아키텍처 - 웹 레이어/도메인 레이어/퍼시스턴스 레이어
        
        ⇒ 퍼시스턴스 레이어(DB)에 주도됨 (나래웨더 산출물작업 → ERD먼저 그리고 인터페이스, 클래스, 유스케이스 정의서 그림)
        
        ⇒ 아래 계층으로만 접근 가능 : 아래 계층으로 모든걸 내려버림 → 아래 계층이 점점 커진다 (수색구조 sar 등)
        
        ⇒ 한 개의 필드만 조작 시에도 모든 도메인 로직을 웹 계층까지 구현해야 함, mock 테스트 코드 설정 복잡해짐
        
        ⇒ 확장에 불리 : 2,3번 문제와 거대한 서비스가 합쳐져서 추가 기능 구현에 어려움 (수색구조 plan ?)
        
        ⇒ 동시 작업이 어려움 (ㅇㅈ)

# 2장 의존성 역전하기
        
- 2장
    - 단일 책임 원칙(Single Responsibility Principle)
        
        하나의 컴포넌트는 오직 한 가지 일만 올바르게 수행해야 한다. 
        → 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.
        
    - 의존성 역전 원칙(Dependency Inversion Principle)
        
        코드상의 어떤 의존성이든 그 방향을 역전시킬 수 있다.
        
        리포지토리 & 리포지토리 구현체(Impl) 을 통해서 가능
        ⇒ 엔티티를 두 계층에서 따로 관리하고 변환해 줘야 함
        
    - 클린 아키텍처
        
        동심원 구조 : 코어[엔티티 ← 유스케이스] ← 포트(입력, 출력) ← 어댑터(웹, DB, 외부시스템)
        
        입력 : 주도하는(driving) 어댑터 : 포트가 유스케이스쪽에 구현, 어댑터에서 호출
        
        출력 : 주도되는(driven) 어댑터 : 포트가 어댑터에 의해 구현, 코어에서 호출
        
    
    실제 코드를 안봐서 직관적으로 와닿지는 않음… 
    
    유스케이스는 무엇이냐? (서비스??)
    
1. **도메인(Domain):**
    - 소프트웨어 시스템이나 애플리케이션을 개발할 때 다루고자 하는 주제나 분야를 가리킵니다. 도메인 주도 개발(Domain Driven Development, DDD)에서는 비즈니스 도메인에 초점을 맞추어 문제 해결을 시도합니다.
2. **ORM(Object-Relational Mapping):**
    - 객체와 데이터베이스 간의 매핑을 자동으로 처리해주는 프로그래밍 기술입니다. 객체 지향 프로그래밍에서 사용되는 객체와 관계형 데이터베이스 간의 불일치를 해결하기 위해 사용됩니다.
3. **Entity:**
    - 도메인 모델에서 식별 가능하고 변경 가능한 객체를 나타냅니다. 데이터베이스에서 테이블에 매핑되는 것이 일반적입니다.
4. **DTO(Data Transfer Object):**
    - 계층 간 데이터 전송을 위한 객체로, 주로 서비스와 클라이언트 간 데이터 교환을 위해 사용됩니다.
5. **Usecase:**
    - 시스템이 수행하는 특정 작업이나 기능을 나타냅니다. Use Case는 유저나 시스템 외부의 다른 엔터티와 상호작용하는 일련의 동작을 설명합니다.
6. **Mocking:**
    - 테스트에서 실제 객체를 대체하는 가짜 객체를 사용하여 테스트하는 것을 가리킵니다. 주로 특정 상황을 시뮬레이션하거나 의존성을 격리하기 위해 사용됩니다.
7. **단일 책임 원칙(Single Responsibility Principle):**
    - 클래스나 모듈은 하나의 책임만 가져야 한다는 원칙입니다. 클래스나 모듈이 한 가지 일만 수행하도록 설계해야 코드의 유지보수성과 이해가 쉬워집니다.
8. **의존성 역전(Dependency Inversion):**
    - 고수준 모듈이 저수준 모듈에 의존하는 것이 아니라, 두 모듈 모두 추상화에 의존해야 한다는 원칙입니다. 이는 시스템의 유연성과 확장성을 높일 수 있습니다.
9. **SOLID:**
    - 객체 지향 설계의 다섯 가지 원칙으로, 단일 책임 원칙, 개방/폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존성 역전 원칙을 나타냅니다.
10. **클린 아키텍처(Clean Architecture):**
    - 소프트웨어 아키텍처를 청결하게 유지하고 각 계층이 명확하게 분리되도록 하는 아키텍처 원칙을 가리킵니다. 주로 도메인, 응용 프로그램, 인프라스트럭처의 계층으로 나뉩니다.
11. **Ports and Adapters:**
    - 클린 아키텍처에서 나온 개념으로, 외부 시스템과의 통신을 담당하는 포트와 실제 구현을 담당하는 어댑터로 시스템을 구성하는 방식을 나타냅니다. 이는 시스템의 외부 의존성을 최소화하고 테스트 용이성을 높이는데 도움이 됩니다.

**의존성 역전(Dependency Inversion):**

의존성 역전은 소프트웨어 설계 원칙 중 하나로, 고수준 모듈이 저수준 모듈에 의존하는 것이 아니라, 둘 다 추상화(인터페이스나 추상 클래스)에 의존해야 한다는 원칙을 의미합니다. 이를 통해 시스템의 유연성과 확장성을 향상시킬 수 있습니다.

일반적으로 소프트웨어 시스템은 고수준 모듈이 저수준 모듈에 의존하는 형태로 설계되어 있습니다. 의존성 역전은 이를 반전시켜 고수준 모듈과 저수준 모듈이 모두 추상화에 의존하게 함으로써 결합도를 낮추고 시스템을 유연하게 만듭니다.

의존성 역전의 주요 이점은 다음과 같습니다:

- 모듈 간의 결합도를 낮춤으로써 코드 수정과 확장을 용이하게 합니다.
- 테스트 용이성을 높이며, 단위 테스트와 모듈 간의 교체가 쉬워집니다.

**SOLID 원칙:**

SOLID는 다섯 가지 객체 지향 설계 원칙의 머리글자를 나타냅니다. 이 원칙들은 소프트웨어의 설계를 개선하고 유지보수성을 높이기 위해 사용됩니다.

1. **단일 책임 원칙(Single Responsibility Principle - SRP):**
    - 하나의 클래스는 하나의 책임만 가져야 한다는 원칙입니다. 클래스가 변경되어야 하는 이유는 단 하나뿐이어야 합니다.
2. **개방/폐쇄 원칙(Open/Closed Principle - OCP):**
    - 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려있어야 하지만, 수정에 대해서는 폐쇄되어야 한다는 원칙입니다. 즉, 새로운 기능을 추가할 때는 기존의 코드를 수정하지 않고 확장할 수 있어야 합니다.
3. **리스코프 치환 원칙(Liskov Substitution Principle - LSP):**
    - 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다는 원칙입니다. 이는 상속 관계에서 하위 클래스는 상위 클래스와 호환성이 있어야 한다는 것을 의미합니다.
4. **인터페이스 분리 원칙(Interface Segregation Principle - ISP):**
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다는 원칙입니다. 즉, 하나의 큰 인터페이스보다는 여러 개의 작은 인터페이스가 더 좋다는 것을 나타냅니다.
5. **의존성 역전 원칙(Dependency Inversion Principle - DIP):**
    - 고수준 모듈은 저수준 모듈에 의존해서는 안되며, 둘 다 추상화에 의존해야 한다는 원칙입니다. 이는 의존성 역전과 밀접한 관련이 있습니다.